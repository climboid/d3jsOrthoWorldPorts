<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <style>

  h1 {
    position: absolute;
    top: 280px;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 18px;
    text-align: center;
    width: 960px;
  }

  canvas{
    position: fixed;
    z-index: -1;
    top:0;
    left: 0;
  }

  </style>
</head>
<body>
  <h1 style="display:none"></h1>
  <div id="mapContainer"></div>
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/1.6.19/topojson.js"></script>
  <script>

    window.onresize = resize;

    var width = window.innerWidth,
          height = window.innerHeight;

    var projection = d3.geo.orthographic()
        .scale(700)
        .translate([width/2, height/2])
        .clipAngle(90);

    function resize() {
      var node = document.getElementById('mapContainer');
      while (node.hasChildNodes()) {
          node.removeChild(node.firstChild);
      };

      makeMap();
    }

    function getScale() {
      var w = window.innerWidth;
      if (w < 2000) {
        return window.innerWidth;
      } else {
        return window.innerWidth - 1000;
      }
    }

    function makeMap() {
      

      var canvas = d3.select("#mapContainer").append("canvas")
          .attr("width", width)
          .attr("height", height);

      var c = canvas.node().getContext("2d");

      var path = d3.geo.path()
          .projection(projection)
          .context(c);

      var title = d3.select("h1");

      queue()
          .defer(d3.json, "world-110m.json")
          .defer(d3.tsv, "world-country-names.tsv")
          .defer(d3.json, "ports.geojson")
          .await(ready);

      function ready(error, world, names, ports) {
        if (error) throw error;


        var globe = {type: "Sphere"},
            land = topojson.feature(world, world.objects.land),
            countries = topojson.feature(world, world.objects.countries).features,
            borders = topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }),
            
            i = 20, // i needs to be the centroid of the region
            n = countries.length;

        

        countries = countries.filter(function(d) {
          return names.some(function(n, index) {
            if (d.id == n.id) return d.name = n.name;
          });
        }).sort(function(a, b) {
          return a.name.localeCompare(b.name);
        });


        function drawPorts() {
          for (var j=0; j<ports.features.length; j++) {
            c.fillStyle = "red", c.beginPath(), path(ports.features[j]), c.fill();
          }
        }

        function transition() {
          d3.transition()
              .duration(1250)
              .each("start", function() {
                title.text(countries[i].name);
              })
              .tween("rotate", function() {
                var p = d3.geo.centroid(countries[i]);
                var r = d3.interpolate(projection.rotate(), [-p[0], -p[1]]);

                return function(t) {

                  projection.rotate(r(t));
                  c.clearRect(0, 0, width, height);
                  //c.fillStyle = "#1073b7", c.beginPath(), path(globe), c.fill();
                  c.fillStyle = "#bbb", c.beginPath(), path(land), c.fill();
                  // c.fillStyle = "#1073b7", c.beginPath(), path(countries[i]), c.fill();
                  c.strokeStyle = "#fff", c.lineWidth = .5, c.beginPath(), path(borders), c.stroke();
                  drawPorts();
                  // c.strokeStyle = "#fff", c.lineWidth = 1, c.beginPath(), path(globe), c.stroke();
                };
              })
            .transition();
        };

        transition();

      }
    }

    function bindEvent() {
      $("canvas").on('click', function() {
        //console.log($(this))
        var offset = $(this).offset();

        var x = event.pageX - offset.left;
        var y = event.pageY - offset.top;

        console.log(x,y);

        console.log(projection);

        console.log(projection.invert([x,y]));

        
      });

    }

    makeMap();
    bindEvent();

  </script>
</body>